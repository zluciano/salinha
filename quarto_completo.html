<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
		<script>
		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
		camera.position.x = 115;
		camera.position.y = 115;
		camera.position.z = 130;
		var controls = new THREE.OrbitControls(camera);

		var renderer = new THREE.WebGLRenderer({antialias:true});
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.BasicShadowMap;
		document.body.appendChild(renderer.domElement);

		var size = 100;

		// Floor and walls
		var planeGeom = new THREE.PlaneBufferGeometry(size, size);
		var wallMat = new THREE.MeshStandardMaterial({
			emissive: 0x708090,
			emissiveIntensity: 0.3,
			color:0xd2ff4d
		});
		var floorMat = new THREE.MeshPhongMaterial({
			emissive: 0x708090,
			emissiveIntensity: 0.3,
			color:0xb3daff
		});
		var wall = new THREE.Mesh(planeGeom, wallMat);
		wall.castShadow = true;
		wall.receiveShadow = true;
		var floor = new THREE.Mesh(planeGeom, floorMat);
		floor.castShadow = true;
		floor.receiveShadow = true;

		function makeWalls(){
			var wallGroup = new THREE.Group();
			rotations = [ [-Math.PI/2.0, 0, 0], [0, Math.PI/2.0, 0], [0, 0, -Math.PI/2.0] ];
			positions = [ [size/2, 0, size/2], [0, size/2, size/2], [size/2, size/2, 0] ];

			for (let i = 0; i < rotations.length; i++) {
				if (i == 0) {
					m = floor.clone();
				} else {
					m = wall.clone();
				}
				m.rotation.x = rotations[i][0];
				m.rotation.y = rotations[i][1];
				m.rotation.z = rotations[i][2];
				m.position.x = positions[i][0];
				m.position.y = positions[i][1];
				m.position.z = positions[i][2];
				wallGroup.add(m);
			}
			scene.add(wallGroup);

			return wallGroup;
		}

		walls = makeWalls();
		scene.add(walls);

		// Bed
		bedXDimension = 27;
		bedZDimension = 50;
		legXDimension = 1;
		legYDimension = 11;
		legZDimension = 1;
		var bedLegGeom = new THREE.BoxGeometry(legXDimension, legYDimension, legZDimension);
		var bedLegMat = new THREE.MeshPhongMaterial({color: 0x669999});
		var bedLeg = new THREE.Mesh(bedLegGeom, bedLegMat);
		bedLeg.receiveShadow = true;
		bedLeg.castShadow = true;

		positions = [ [size-legXDimension/2, legZDimension/2],
									[size-bedXDimension+legXDimension/2, legZDimension/2],
									[size-legXDimension/2, bedZDimension-legZDimension/2],
									[size-bedXDimension+legXDimension/2, bedZDimension-legZDimension/2] ];

		var bedGroup = new THREE.Group();

		// Adding bed legs to the group
		for(let i = 0; i < positions.length; i++){
			x = positions[i][0];
			y = legYDimension/2;
			z = positions[i][1];
			m = bedLeg.clone();
			m.position.x = x;
			m.position.y = y;
			m.position.z = z;
			bedGroup.add(m);
		}

		var bedFrameThickness = 1;
		var bedFrameGeom = new THREE.BoxGeometry(bedXDimension, bedFrameThickness, bedZDimension);
		var bedFrameMat = new THREE.MeshPhongMaterial({color:0x669999});
		var bedFrame = new THREE.Mesh(bedFrameGeom, bedFrameMat);
		bedFrame.receiveShadow = true;
		bedFrame.castShadow = true;

		bedFrame.position.x = size - bedXDimension/2;
		bedFrame.position.y = legYDimension + bedFrameThickness/2;
		bedFrame.position.z = bedZDimension/2;
		bedGroup.add(bedFrame);

		var bedMattressThickness = 5;
		var bedMattressGeom = new THREE.BoxGeometry(bedXDimension, bedMattressThickness, bedZDimension - legZDimension);
		var bedMattressMat = new THREE.MeshPhongMaterial({color:0xdddddd});
		var bedMattress = new THREE.Mesh(bedMattressGeom, bedMattressMat);
		bedMattress.receiveShadow = true;
		bedMattress.castShadow = true;

		bedMattress.position.x = size - bedXDimension/2;
		bedMattress.position.y = legYDimension + bedFrameThickness + bedMattressThickness/2;
		bedMattress.position.z = bedZDimension/2 + legZDimension/2;
		bedGroup.add(bedMattress);

		var bedBackFrameHeight = 13;
		var bedBackFrameGeom = new THREE.BoxGeometry(bedXDimension, bedBackFrameHeight, legZDimension);
		var bedBackFrameMat = new THREE.MeshPhongMaterial({color:0x669999});
		var bedBackFrame = new THREE.Mesh(bedBackFrameGeom, bedBackFrameMat);
		bedBackFrame.receiveShadow = true;
		bedBackFrame.castShadow = true;

		bedBackFrame.position.x = size - bedXDimension/2;
		bedBackFrame.position.y = legYDimension + bedFrameThickness/2 + bedBackFrameHeight/2;
		bedBackFrame.position.z = legZDimension/2;
		bedGroup.add(bedBackFrame);

		scene.add(bedGroup);

		// Wardrobe
		var wardrobeDim = [27, 60, 40];
		var wardrobeGeom = new THREE.BoxGeometry(wardrobeDim[0], wardrobeDim[1], wardrobeDim[2]);
		var wardrobeMat = new THREE.MeshPhongMaterial({color: 0xdddddd});
		var wardrobe = new THREE.Mesh(wardrobeGeom, wardrobeMat);

		wardrobe.position.x = wardrobeDim[0]/2;
		wardrobe.position.y = wardrobeDim[1]/2;
		wardrobe.position.z = size*0.8-wardrobeDim[2]/2;

		wardrobe.receiveShadow = true;
		wardrobe.castShadow = true;
		scene.add(wardrobe);

		// Door
		var doorDimension = [1, 45, 20];
		var offset = [doorDimension[0]/2, doorDimension[1]/2, -doorDimension[2]/2];
		var doorGeom = new THREE.BoxGeometry(doorDimension[0], doorDimension[1], -doorDimension[2]);
		doorGeom.translate(offset[0], offset[1], offset[2]);
		var doorMat = new THREE.MeshPhongMaterial({color: 0xdddddd});
		var door = new THREE.Mesh(doorGeom, doorMat);

		door.position.x = size - doorDimension[0]/2;
		door.position.y = 0;
		door.position.z = size*0.9;

		door.receiveShadow = true;
		scene.add(door);

		// Desk
		var tableDim = [67, 1, 27];
		var table = new THREE.Geometry();
		var r1 = 3;
		var r2 = 9;

		table.vertices.push(new THREE.Vector3(0, 0, 0));
		table.vertices.push(new THREE.Vector3(tableDim[0], 0, 0));

		for (let theta = 0 ; theta <= Math.PI/2 ; theta += Math.PI/18)
		  table.vertices.push(new THREE.Vector3(tableDim[0] - r1 + r1*Math.cos(theta), 0, tableDim[2] + r1*Math.sin(theta)));

		for (let theta = 0 ; theta <= Math.PI/2 ; theta += Math.PI/18)
		  table.vertices.push(new THREE.Vector3(wardrobeDim[0] + r2*(1-Math.sin(theta)), 0, tableDim[2] + r1 + r2*(1-Math.cos(theta))));

		table.vertices.push(new THREE.Vector3(0, 0, tableDim[2] + r1 + r2));

		table.vertices.push(new THREE.Vector3(0, tableDim[1], 0));
		table.vertices.push(new THREE.Vector3(tableDim[0], tableDim[1], 0));

		for (let theta = 0 ; theta <= Math.PI/2 ; theta += Math.PI/18)
		  table.vertices.push(new THREE.Vector3(tableDim[0] - r1 + r1*Math.cos(theta), tableDim[1], tableDim[2] + r1*Math.sin(theta)));

		for (let theta = 0 ; theta <= Math.PI/2 ; theta += Math.PI/18)
		  table.vertices.push(new THREE.Vector3(wardrobeDim[0] + r2*(1-Math.sin(theta)), tableDim[1], tableDim[2] + r1 + r2*(1-Math.cos(theta))));

		table.vertices.push(new THREE.Vector3(0, tableDim[1], tableDim[2] + r1 + r2));

		var face = [];
		for (let i = 0; i < (table.vertices.length-1)/2 - 2; i++) {
		  face[i] = new THREE.Face3(0, i+1, i+2);
		  table.faces.push(face[i]);
		}
		for (let i = Math.floor((table.vertices.length+1)/2); i < table.vertices.length - 2; i++) {
		  face[i] = new THREE.Face3(Math.floor((table.vertices.length+1)/2), i+1, i+2);
		  table.faces.push(face[i]);
		}

		// Connecting sides
		let i = 0;
		while (i < (table.vertices.length-1)/2) {
		  face[i] = new THREE.Face3(i, i + Math.floor((table.vertices.length+1)/2), i+1);
		  table.faces.push(face[i]);
		  i++;
		  if (i < (table.vertices.length-1)/2) {
		    face[i] = new THREE.Face3(i, Math.floor((table.vertices.length+1)/2) + i-1, Math.floor((table.vertices.length+1)/2)+i);
		    table.faces.push(face[i]);
		  }
		}

		table.faceVertexUvs = new Array();
		table.faceVertexUvs.push(new Array());

		for (let i = 0; i < table.faces.length; i++) {
		  let v1 = table.vertices[table.faces[i].a],
		  v2 = table.vertices[table.faces[i].b],
		  v3 = table.vertices[table.faces[i].c];

		  table.faceVertexUvs[0].push([
		    new THREE.Vector2(v1.x/tableDim[0], v1.y/tableDim[1]),
		    new THREE.Vector2(v2.x/tableDim[0], v2.y/tableDim[1]),
		    new THREE.Vector2(v3.x/tableDim[0], v3.y/tableDim[1])
		  ]);
		}

		var textureLoader = new THREE.TextureLoader();
		var texture = textureLoader.load("img/wood.jpg");

		table.computeFaceNormals();
		table.computeVertexNormals();

		table.colorsNeedUpdate = true;
		table.verticesNeedUpdate = true;
		table.uvsNeedUpdate = true;
		table.dynamic = true;

		var table_mesh = new THREE.Mesh(table,
		  new THREE.MeshBasicMaterial({
		    vertexColors: THREE.VertexColors,
		    side: THREE.DoubleSide,
		    map: texture,
		  })
		);
		scene.add(table_mesh);

		table_mesh.castShadow = true;
		table_mesh.receiveShadow = true;

		var supportDimension = [1, 25, 26];
		var supportGeom = new THREE.BoxGeometry(supportDimension[0], supportDimension[1], supportDimension[2]);
		var supportMat = new THREE.MeshPhongMaterial({color: 0xffffff});
		var support = new THREE.Mesh(supportGeom, supportMat);
		support.castShadow = true;
		support.receiveShadow = true;

		var desk = new THREE.Group();

		// Changing table position
		table_mesh.position.y = supportDimension[1]

		support.position.x = tableDim[0] - supportDimension[0]/2;
		support.position.y = supportDimension[1]/2;
		support.position.z = supportDimension[2]/2;

		desk.add(table);
		desk.add(support);

		scene.add(desk);

		// Chair
		function makeChair(col = 0x669999) {
			var chairLegGeom = new THREE.BoxGeometry(3, 16, 3);
			var chairLegMat = new THREE.MeshLambertMaterial({color: col});
			var chairLeg = new THREE.Mesh(chairLegGeom, chairLegMat);
			chairLeg.castShadow = true;
			chairLeg.receiveShadow = true;

			chairLegpositions = [ [0,0], [15, 0], [15, 15], [0, 15] ];

			var chairLegs = new THREE.Group()
			for (let i = 0; i < chairLegpositions.length; i++) {
				x = chairLegpositions[i][0];
				z = chairLegpositions[i][1];
				m = chairLeg.clone();
				m.position.x = x;
				m.position.z = z;
				m.position.y = 0;
				chairLegs.add(m);
			}

			var chairSeatGeom = new THREE.BoxGeometry(18, 2, 18);
			var chairSeatMat = new THREE.MeshLambertMaterial({color:col});
			var chairSeat = new THREE.Mesh(chairSeatGeom,chairSeatMat);
			chairSeat.castShadow = true;
			chairSeat.receiveShadow = true;

			chairSeat.position.set(7.5, 8, 7.5);

			var chairBackrestGeom = new THREE.BoxGeometry(18, 18, 2);
			var chairBackrestMat = new THREE.MeshLambertMaterial({color:col});
			var chairBackrest = new THREE.Mesh(chairBackrestGeom, chairBackrestMat);
			chairBackrest.castShadow = true;
			chairBackrest.receiveShadow = true;

			chairBackrest.position.set(7.5, 18, -0.5);

			var chairGroup = new THREE.Group();
			chairGroup.add(chairLegs);
			chairGroup.add(chairSeat);
			chairGroup.add(chairBackrest);

			return chairGroup;
		}

		studyChair = makeChair();
		studyChair.position.x = 60;
		studyChair.position.y = 7.5;
		studyChair.position.z = 35;
		studyChair.rotation.y = Math.PI;

		scene.add(studyChair);

		// Light
		var ambientLight = new THREE.AmbientLight(0xffffff, 0.35); // soft white light

		var lightBulb = new THREE.PointLight(0x303030, 0.8);
		lightBulb.castShadow = true;
		lightBulb.shadow.camera.near = 10;
		lightBulb.shadow.camera.far = 250;

		lightBulb1 = lightBulb.clone();
		lightBulb1.position.set(50, 80, 50);

		lightBulb2 = lightBulb.clone();
		lightBulb2.position.set(size*8.5, 50, 2);

		scene.add(ambientLight);
		scene.add(lightBulb1);

		var open = 1;
		var inc = 1;
		// Rendering
		var animate = function () {
			requestAnimationFrame(animate);
			controls.update();

			// Rotation
			if (door.rotation.y <= -85 * Math.PI/180) {
				open = 1;
				door.rotation.y += 0.01;
			} else if (door.rotation.y >= 0) {
				open = 0;
				door.rotation.y -= 0.01;
			} else if (!open) {
				door.rotation.y -= 0.01;
			} else {
				door.rotation.y += 0.01;
			}

			// Chair Moving
			if (studyChair.position.z >= 70) {
				inc = 0;
				studyChair.position.z -= 0.5;
			} else if (studyChair.position.z <= 35) {
				inc = 1;
				studyChair.position.z += 0.5;
			} else if (inc) {
				studyChair.position.z += 0.5;
			} else {
				studyChair.position.z -= 0.5;
			}

			renderer.render(scene, camera);
		};

		animate();

    </script>
	</body>
</html>
