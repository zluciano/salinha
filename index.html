<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
		<script>
		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
		camera.position.x = 11.5;
		camera.position.y = 11.5;
		camera.position.z = 13;
		var controls = new THREE.OrbitControls(camera);

		var renderer = new THREE.WebGLRenderer({antialias:true});
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.BasicShadowMap;
		document.body.appendChild(renderer.domElement);

		var size = 10;

		// Floor and walls
		var planeGeom = new THREE.PlaneBufferGeometry(size, size);
		var wallMat = new THREE.MeshStandardMaterial({
			emissive: 0x708090,
			emissiveIntensity: 0.3,
			color:0xd2ff4d
		});
		var floorMat = new THREE.MeshPhongMaterial({
			emissive: 0x708090,
			emissiveIntensity: 0.3,
			color:0xb3daff
		});
		var wall = new THREE.Mesh(planeGeom, wallMat);
		wall.castShadow = true;
		wall.receiveShadow = true;
		var floor = new THREE.Mesh(planeGeom, floorMat);
		floor.castShadow = true;
		floor.receiveShadow = true;

		function makeWalls(){
			var wallGroup = new THREE.Group();
			rotations = [ [-Math.PI/2.0, 0, 0], [0, Math.PI/2.0, 0], [0, 0, -Math.PI/2.0] ];
			positions = [ [size/2, 0, size/2], [0, size/2, size/2], [size/2, size/2, 0] ];

			for (let i = 0; i < rotations.length; i++) {
				if (i == 0) {
					m = floor.clone();
				} else {
					m = wall.clone();
				}
				m.rotation.x = rotations[i][0];
				m.rotation.y = rotations[i][1];
				m.rotation.z = rotations[i][2];
				m.position.x = positions[i][0];
				m.position.y = positions[i][1];
				m.position.z = positions[i][2];
				wallGroup.add(m);
			}
			scene.add(wallGroup);

			return wallGroup;
		}

		walls = makeWalls();
		scene.add(walls);

		// Bed
		bedXDimension = 2.7;
		bedZDimension = 5;
		legXDimension = 0.1;
		legYDimension = 1.1;
		legZDimension = 0.1;
		var bedLegGeom = new THREE.BoxGeometry(legXDimension, legYDimension, legZDimension);
		var bedLegMat = new THREE.MeshPhongMaterial({color: 0x669999});
		var bedLeg = new THREE.Mesh(bedLegGeom, bedLegMat);
		bedLeg.receiveShadow = true;
		bedLeg.castShadow = true;

		positions = [ [size-legXDimension/2, legZDimension/2],
									[size-bedXDimension+legXDimension/2, legZDimension/2],
									[size-legXDimension/2, bedZDimension-legZDimension/2],
									[size-bedXDimension+legXDimension/2, bedZDimension-legZDimension/2] ];

		var bedGroup = new THREE.Group();

		// Adding bed legs to the group
		for(let i = 0; i < positions.length; i++){
			x = positions[i][0];
			y = legYDimension/2;
			z = positions[i][1];
			m = bedLeg.clone();
			m.position.x = x;
			m.position.y = y;
			m.position.z = z;
			bedGroup.add(m);
		}

		var bedFrameThickness = 0.1;
		var bedFrameGeom = new THREE.BoxGeometry(bedXDimension, bedFrameThickness, bedZDimension);
		var bedFrameMat = new THREE.MeshPhongMaterial({color:0x669999});
		var bedFrame = new THREE.Mesh(bedFrameGeom, bedFrameMat);
		bedFrame.receiveShadow = true;
		bedFrame.castShadow = true;

		bedFrame.position.x = size - bedXDimension/2;
		bedFrame.position.y = legYDimension + bedFrameThickness/2;
		bedFrame.position.z = bedZDimension/2;
		bedGroup.add(bedFrame);

		var bedMattressThickness = 0.5;
		var bedMattressGeom = new THREE.BoxGeometry(bedXDimension, bedMattressThickness, bedZDimension - legZDimension);
		var bedMattressMat = new THREE.MeshPhongMaterial({color:0xdddddd});
		var bedMattress = new THREE.Mesh(bedMattressGeom, bedMattressMat);
		bedMattress.receiveShadow = true;
		bedMattress.castShadow = true;

		bedMattress.position.x = size - bedXDimension/2;
		bedMattress.position.y = legYDimension + bedFrameThickness + bedMattressThickness/2;
		bedMattress.position.z = bedZDimension/2 + legZDimension/2;
		bedGroup.add(bedMattress);

		var bedBackFrameHeight = 1.3;
		var bedBackFrameGeom = new THREE.BoxGeometry(bedXDimension, bedBackFrameHeight, legZDimension);
		var bedBackFrameMat = new THREE.MeshPhongMaterial({color:0x669999});
		var bedBackFrame = new THREE.Mesh(bedBackFrameGeom, bedBackFrameMat);
		bedBackFrame.receiveShadow = true;
		bedBackFrame.castShadow = true;

		bedBackFrame.position.x = size - bedXDimension/2;
		bedBackFrame.position.y = legYDimension + bedFrameThickness/2 + bedBackFrameHeight/2;
		bedBackFrame.position.z = legZDimension/2;
		bedGroup.add(bedBackFrame);

		scene.add(bedGroup);

		// Wardrobe
		var wardrobeDim = [2.7, 6, 4];
		var wardrobeGeom = new THREE.BoxGeometry(wardrobeDim[0], wardrobeDim[1], wardrobeDim[2]);
		var wardrobeMat = new THREE.MeshPhongMaterial({color: 0xdddddd});
		var wardrobe = new THREE.Mesh(wardrobeGeom, wardrobeMat);

		wardrobe.position.x = wardrobeDim[0]/2;
		wardrobe.position.y = wardrobeDim[1]/2;
		wardrobe.position.z = size*0.8-wardrobeDim[2]/2;

		wardrobe.receiveShadow = true;
		wardrobe.castShadow = true;
		scene.add(wardrobe);

		// Door
		var doorDimension = [0.1, 4.5, 2];
		var offset = [doorDimension[0]/2, doorDimension[1]/2, -doorDimension[2]/2];
		var doorGeom = new THREE.BoxGeometry(doorDimension[0], doorDimension[1], -doorDimension[2]);
		doorGeom.translate(offset[0], offset[1], offset[2]);
		var doorMat = new THREE.MeshPhongMaterial({color: 0xdddddd});
		var door = new THREE.Mesh(doorGeom, doorMat);

		door.position.x = size - doorDimension[0]/2;
		door.position.y = 0;
		door.position.z = size*0.9;

		door.receiveShadow = true;
		scene.add(door);

		// Desk
		var tableDim = [6.7, 0.1, 2.7];
		var table = new THREE.Geometry();
		var r1 = 0.3;
		var r2 = 0.9;

		table.vertices.push(new THREE.Vector3(0, 0, 0));
		table.vertices.push(new THREE.Vector3(tableDim[0], 0, 0));

		for (let theta = 0 ; theta <= Math.PI/2 ; theta += Math.PI/18)
		  table.vertices.push(new THREE.Vector3(tableDim[0] - r1 + r1*Math.cos(theta), 0, tableDim[2] + r1*Math.sin(theta)));

		for (let theta = 0 ; theta <= Math.PI/2 ; theta += Math.PI/18)
		  table.vertices.push(new THREE.Vector3(wardrobeDim[0] + r2*(1-Math.sin(theta)), 0, tableDim[2] + r1 + r2*(1-Math.cos(theta))));

		table.vertices.push(new THREE.Vector3(0, 0, tableDim[2] + r1 + r2));

		table.vertices.push(new THREE.Vector3(0, tableDim[1], 0));
		table.vertices.push(new THREE.Vector3(tableDim[0], tableDim[1], 0));

		for (let theta = 0 ; theta <= Math.PI/2 ; theta += Math.PI/18)
		  table.vertices.push(new THREE.Vector3(tableDim[0] - r1 + r1*Math.cos(theta), tableDim[1], tableDim[2] + r1*Math.sin(theta)));

		for (let theta = 0 ; theta <= Math.PI/2 ; theta += Math.PI/18)
		  table.vertices.push(new THREE.Vector3(wardrobeDim[0] + r2*(1-Math.sin(theta)), tableDim[1], tableDim[2] + r1 + r2*(1-Math.cos(theta))));

		table.vertices.push(new THREE.Vector3(0, tableDim[1], tableDim[2] + r1 + r2));

		var face = [];
		for (let i = 0; i < (table.vertices.length-1)/2 - 2; i++) {
		  face[i] = new THREE.Face3(0, i+1, i+2);
		  table.faces.push(face[i]);
		}
		for (let i = Math.floor((table.vertices.length+1)/2); i < table.vertices.length - 2; i++) {
		  face[i] = new THREE.Face3(Math.floor((table.vertices.length+1)/2), i+1, i+2);
		  table.faces.push(face[i]);
		}

		// Connecting sides
		let i = 0;
		while (i < (table.vertices.length-1)/2) {
		  face[i] = new THREE.Face3(i, i + Math.floor((table.vertices.length+1)/2), i+1);
		  table.faces.push(face[i]);
		  i++;
		  if (i < (table.vertices.length-1)/2) {
		    face[i] = new THREE.Face3(i, Math.floor((table.vertices.length+1)/2) + i-1, Math.floor((table.vertices.length+1)/2)+i);
		    table.faces.push(face[i]);
		  }
		}

		table.faceVertexUvs = new Array();
		table.faceVertexUvs.push(new Array());

		for (let i = 0; i < table.faces.length; i++) {
		  let v1 = table.vertices[table.faces[i].a],
		  v2 = table.vertices[table.faces[i].b],
		  v3 = table.vertices[table.faces[i].c];

		  table.faceVertexUvs[0].push([
		    new THREE.Vector2(v1.x/tableDim[0], v1.y/tableDim[1]),
		    new THREE.Vector2(v2.x/tableDim[0], v2.y/tableDim[1]),
		    new THREE.Vector2(v3.x/tableDim[0], v3.y/tableDim[1])
		  ]);
		}

		var textureLoader = new THREE.TextureLoader();
		var texture = textureLoader.load("img/wood.jpg");

		table.computeFaceNormals();
		table.computeVertexNormals();

		table.colorsNeedUpdate = true;
		table.verticesNeedUpdate = true;
		table.uvsNeedUpdate = true;
		table.dynamic = true;

		var table_mesh = new THREE.Mesh(table,
		  new THREE.MeshBasicMaterial({
		    vertexColors: THREE.VertexColors,
		    side: THREE.DoubleSide,
		    map: texture,
		  })
		);
		scene.add(table_mesh);

		table_mesh.castShadow = true;
		table_mesh.receiveShadow = true;

		var supportDimension = [0.1, 2.5, 2.6];
		var supportGeom = new THREE.BoxGeometry(supportDimension[0], supportDimension[1], supportDimension[2]);
		var supportMat = new THREE.MeshPhongMaterial({color: 0xffffff});
		var support = new THREE.Mesh(supportGeom, supportMat);
		support.castShadow = true;
		support.receiveShadow = true;

		var desk = new THREE.Group();

		// Changing table position
		table_mesh.position.y = supportDimension[1]

		support.position.x = tableDim[0] - supportDimension[0]/2;
		support.position.y = supportDimension[1]/2;
		support.position.z = supportDimension[2]/2;

		desk.add(table);
		desk.add(support);

		scene.add(desk);

		// Chair
		function makeChair(col = 0x669999) {
			var chairLegGeom = new THREE.BoxGeometry(0.3, 1.6, 0.3);
			var chairLegMat = new THREE.MeshLambertMaterial({color: col});
			var chairLeg = new THREE.Mesh(chairLegGeom, chairLegMat);
			chairLeg.castShadow = true;
			chairLeg.receiveShadow = true;

			chairLegpositions = [ [0,0], [1.5, 0], [1.5, 1.5], [0, 1.5] ];

			var chairLegs = new THREE.Group()
			for (let i = 0; i < chairLegpositions.length; i++) {
				x = chairLegpositions[i][0];
				z = chairLegpositions[i][1];
				m = chairLeg.clone();
				m.position.x = x;
				m.position.z = z;
				m.position.y = 0;
				chairLegs.add(m);
			}

			var chairSeatGeom = new THREE.BoxGeometry(1.8, 0.2, 1.8);
			var chairSeatMat = new THREE.MeshLambertMaterial({color:col});
			var chairSeat = new THREE.Mesh(chairSeatGeom,chairSeatMat);
			chairSeat.castShadow = true;
			chairSeat.receiveShadow = true;

			chairSeat.position.set(0.75, 0.8, 0.75);

			var chairBackrestGeom = new THREE.BoxGeometry(1.8, 1.8, 0.2);
			var chairBackrestMat = new THREE.MeshLambertMaterial({color:col});
			var chairBackrest = new THREE.Mesh(chairBackrestGeom, chairBackrestMat);
			chairBackrest.castShadow = true;
			chairBackrest.receiveShadow = true;

			chairBackrest.position.set(0.75, 1.8, -0.05);

			var chairGroup = new THREE.Group();
			chairGroup.add(chairLegs);
			chairGroup.add(chairSeat);
			chairGroup.add(chairBackrest);

			return chairGroup;
		}

		studyChair = makeChair();
		studyChair.position.x = 6;
		studyChair.position.y = 0.75;
		studyChair.position.z = 3.5;
		studyChair.rotation.y = Math.PI;

		scene.add(studyChair);

		// Books
		function addBook(dimension, position, col=0xdddddd){
			var bookGeom = new THREE.BoxGeometry(dimension[0], dimension[1], dimension[2]);
			var bookMat = new THREE.MeshLambertMaterial({color: col});
			let book = new THREE.Mesh(bookGeom, bookMat);
			book.castShadow = true;
			book.receiveShadow = true;

			book.position.x = position[0];
			book.position.y = position[1];
			book.position.z = position[2];
			scene.add(book);

			return book;
		}

		book1 = addBook([0.5, 0.1, 0.8], [tableDim[0]/4, supportDimension[1] + tableDim[1] + 0.1/2, tableDim[2]/2]);
		book2 = addBook([0.4, 0.05, 0.6], [tableDim[0]/2, supportDimension[1] + tableDim[1] + 0.05/2, tableDim[2]/2]);
		book3 = addBook([0.5, 0.13, 0.8], [4*tableDim[0]/5, supportDimension[1] + tableDim[1] + 0.05, tableDim[2]/2]);

		// Light
		var ambientLight = new THREE.AmbientLight(0xffffff, 0.35); // soft white light

		var lightBulb = new THREE.PointLight(0x303030, 0.8);
		lightBulb.castShadow = true;
		lightBulb.shadow.camera.near = 0.1;
		lightBulb.shadow.camera.far = 25;

		lightBulb1 = lightBulb.clone();
		lightBulb1.position.set(1.5, 5, 0.2);

		lightBulb2 = lightBulb.clone();
		lightBulb2.position.set(size*0.85, 5, 0.2);

		scene.add(ambientLight);
		scene.add(lightBulb1);
		scene.add(lightBulb2);

		var open = 1;
		var inc = 1;
		// Rendering
		var animate = function () {
			requestAnimationFrame(animate);
			controls.update();

			// Rotation
			if (door.rotation.y <= -85 * Math.PI/180) {
				open = 1;
				door.rotation.y += 0.01;
			} else if (door.rotation.y >= 0) {
				open = 0;
				door.rotation.y -= 0.01;
			} else if (!open) {
				door.rotation.y -= 0.01;
			} else {
				door.rotation.y += 0.01;
			}

			// Chair Moving
			if (studyChair.position.z >= 7) {
				inc = 0;
				studyChair.position.z -= 0.05;
			} else if (studyChair.position.z <= 3.5) {
				inc = 1;
				studyChair.position.z += 0.05;
			} else if (inc) {
				studyChair.position.z += 0.05;
			} else {
				studyChair.position.z -= 0.05;
			}

			renderer.render(scene, camera);
		};

		animate();

    </script>
	</body>
</html>
